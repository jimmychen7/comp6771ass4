// Element
template <typename T>
btree<T>::Node::Element::Element()
    : leftChild_{std::make_shared<Node>(nullptr)}
    , rightChild_{std::make_shared<Node>(nullptr)} {
}

template <typename T>
btree<T>::Node::Element::~Element() {
}

template <typename T>
btree<T>::Node::Element::Element(T value)
    : Element() {
    value_ = value;
}

template <typename T>
T btree<T>::Node::Element::getValue() {
    return value_;
}

template <typename T>
std::shared_ptr<typename btree<T>::Node>
        btree<T>::Node::Element::getLeftChild() {
    return leftChild_;
}

template <typename T>
std::shared_ptr<typename btree<T>::Node>
        btree<T>::Node::Element::getRightChild() {
    return rightChild_;
}
template <typename T>
std::shared_ptr<typename btree<T>::Node::Element>
btree<T>::Node::Element::getNext() {
    return next_;
}

template <typename T>
std::shared_ptr<typename btree<T>::Node::Element>
btree<T>::Node::Element::getPrev() {
    return prev_;
}

template <typename T>
void btree<T>::Node::Element::setValue(T value) {
    value_ = value;
}
            
template <typename T>
void btree<T>::Node::Element::setLeftChild(std::shared_ptr<Node> sharedPtr) {
    leftChild_ = sharedPtr;
}

template <typename T>
void btree<T>::Node::Element::setRightChild(std::shared_ptr<Node> sharedPtr) {
    rightChild_ = sharedPtr;
}
template <typename T>
void btree<T>::Node::Element::setNext(std::shared_ptr<Element> elem) {
    next_ = elem;
}

template <typename T>
void btree<T>::Node::Element::setPrev(std::shared_ptr<Element> elem) {
    prev_ = elem;
}

// Node
template <typename T>
btree<T>::Node::Node()
    : elems_{std::vector<std::shared_ptr<Element>>()} {
}

template <typename T>
btree<T>::Node::~Node() {
}

template <typename T>
bool btree<T>::Node::isEmpty() {
    return elems_.empty();
}

template <typename T>
bool btree<T>::Node::isFull() {
    return elems_.size() >= maxNumElems_;
}

template <typename T>
std::vector<std::shared_ptr<typename btree<T>::Node::Element>>
btree<T>::Node::getElements() {
    return elems_;
}

// btree
template <typename T>
btree<T>::btree(size_t maxNumElems)
    : maxNumElems_{maxNumElems}
    , root_{std::make_shared<Node>(Node())} {
}

template <typename T>
btree<T>::btree(const btree<T>& original) {
    //TODO
}

template <typename T>
btree_iterator<T> btree<T>::find(const T& elem) {
    //TODO
    auto nodesToSearch = std::queue<std::shared_ptr<Node>>();
    nodesToSearch.push(root_);
    
    while(!nodesToSearch.empty()) {
        Node *node = nodesToSearch.pop().get();
        std::vector<std::shared_ptr<Element>> elems = node->getElements();
        
        for(int i = 0; i < elems.size(); ++i) {
            Element *currElem = elems.at(i).get();
            
            if(elemPtr->getValue() == elem) {
                return btree_iterator(currElem);
            } else if(elemPtr->getValue() > elem) {
                std::shared_ptr<Node> nodeToSearch = elemPtr->getLeftChild();
                if(nodeToSearch.get() != nullptr) {
                    nodesToSearch.push(nodetoSearch);
                }
                break;
            } else if(i == elems.size() - 1) {
                //last elem in the node
                std::shared_ptr<Node> nodeToSearch = elemPtr->getRightChild();
                if(nodeToSearch.get() != nullptr) {
                    nodesToSearch.push(nodetoSearch);
                }
            }
        }
    }
    return end();
}


template <typename T>
const_btree_iterator<T> btree<T>::find(const T& elem) const {
    //TODO
    auto nodesToSearch = std::queue<std::shared_ptr<Node>>();
    nodesToSearch.push(root_);
    
    while(!nodesToSearch.empty()) {
        Node *node = nodesToSearch.pop().get();
        std::vector<std::shared_ptr<Element>> elems = node->getElements();
        
        for(int i = 0; i < elems.size(); ++i) {
            Element *currElem = elems.at(i).get();
            
            if(elemPtr->getValue() == elem) {
                return btree_iterator(currElem);
            } else if(elemPtr->getValue() > elem) {
                std::shared_ptr<Node> nodeToSearch = elemPtr->getLeftChild();
                if(nodeToSearch.get() != nullptr) {
                    nodesToSearch.push(nodetoSearch);
                }
                break;
            } else if(i == elems.size() - 1) {
                //last elem in the node
                std::shared_ptr<Node> nodeToSearch = elemPtr->getRightChild();
                if(nodeToSearch.get() != nullptr) {
                    nodesToSearch.push(nodetoSearch);
                }
            }
        }
    }
    return cend();
}

template <typename T>
std::pair<btree_iterator<T>, bool> btree<T>::insert(const T& elem) {
    //TODO
    auto it = find(elem);
    if(it != end()) {
        return std::pair<btree_iterator<T>, bool>(it, false);
    }
    
    auto nodesToSearch = std::queue<std::shared_ptr<Node>>();
    nodesToSearch.push(root_);
    
    bool done = false;
    
    while(!nodesToSearch.empty() && !done) {
        Node node = *nodesToSearch.pop().get();
        auto elems = node.getElements();
        
        for(int i = 0; i < elems.size(); ++i) {
            elemePtr = elems.at(i).get();
            if(elemPtr->getValue() == elem) {
                return std::pair<btree_iterator<T>, bool> (
                                            btree_iterator(elemPtr), false);
            } else if (elemPtr->getValue() > elem) {
                // passed
                preElemPtr = elemPtr->getPrev();
                
                done = true;
            }
        }
        
        if(node.isFull()) {
            // add child nodes to the search
            std::shared_ptr<Node> leftChildPtr, rightChildPtr;
            Element firstElement, currElement;
            
            firstElement = elements.at(0);
            leftChildPtr = firstElement.getLeftChild();
            rightChildPtr = firstElement.getRightChild();
            if(leftChildPtr.get() != nullptr) {
                nodesToPrint.push(leftChildPtr);
            }
            if(rightChildPtr.get() != nullptr) {
                nodesToPrint.push(rightChildPtr);
            }
            for (int i = 1; i < elements.size(); i++) {
                currElement = elements.at(i);
                rightChildPtr = currElement.getRightChild();
                if(rightChildPtr.get() != nullptr) {
                    nodesToPrint.push(rightChildPtr);
                }
            }
        }
    }
    
    if (!done) {
        
    }
    
    return std::pair<btree_iterator<T>, bool>(newElem ,true);
}

template <typename T>
btree<T>::~btree() {
}

template <typename T>
std::ostream& operator<< (std::ostream& os, const btree<T>& tree) {
    typedef typename btree<T>::Node Node;
    typedef typename btree<T>::Node::Element Element;
    auto nodesToPrint = std::queue<std::shared_ptr<Node>>();
    
    nodesToPrint.push(tree.root_);
    
    while(!nodesToPrint.empty()) {
        Node node = *nodesToPrint.pop().get();
        
        std::vector<Element> elements = node.getElements();
        
        for (int i = 0; i < elements.size(); i++) {
            Element currElement = elements.at(i);
            if (i == 0 && nodesToPrint.empty()) {
                // first element of root node
                os << currElement.getValue();
            } else {
                os << " " << currElement.getValue();
            }
        }
        
        if(node.isFull()) {
            std::shared_ptr<Node> leftChildPtr, rightChildPtr;
            Element firstElement, currElement;
            
            firstElement = elements.at(0);
            leftChildPtr = firstElement.getLeftChild();
            rightChildPtr = firstElement.getRightChild();
            if(leftChildPtr.get() != nullptr) {
                nodesToPrint.push(leftChildPtr);
            }
            if(rightChildPtr.get() != nullptr) {
                nodesToPrint.push(rightChildPtr);
            }
            for (int i = 1; i < elements.size(); i++) {
                currElement = elements.at(i);
                rightChildPtr = currElement.getRightChild();
                if(rightChildPtr.get() != nullptr) {
                    nodesToPrint.push(rightChildPtr);
                }
            }
        }
        
    }
    os << std::endl;
    return os;
}
    
    /*
    if (obj.size_ == 0) {
        return os << "[]";
    }
    
    unsigned int i = 0;
    os << "[";
    while (i < obj.size_ - 1)
    {
        os << obj.ev_[i] << " ";
        i++;
    }
    os << obj.ev_[i] << "]";
    return os;*/

